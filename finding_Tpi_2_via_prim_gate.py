import numpy as np
from scipy.linalg import expm
import matplotlib.pyplot as plt
import math

def swap(M):
    SWAP = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])
    return np.dot(np.dot(SWAP, M), SWAP)


Ez = 3.933e10
dEz = 1.326e7
Ω = 410000.0
J = 1.59e6

n = 1
# T_pi_2 = 6.089596456300971e-07
# T_pi_2 = math.sqrt(16*n**2-1)/4/J
# T_pi_2 = 1.0/(4.0*Ω)

I = np.identity(2)
X = np.array([[0,   1], [1,  0]])
Y = np.array([[0, -1j], [1j, 0]])
Z = np.array([[1,   0], [0, -1]])

Z_2_1 = (1/np.sqrt(2))*np.array([[1-1j, 0+0j], [0+0j, 1+1j]])
CNOT = np.array([[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0]])
NCNOT = np.array([[0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1]])
X_2_1 = (1/np.sqrt(2))*np.array([[1+0j, 0-1j], [0-1j, 1+0j]])

# Following generators operate on Q1.
X_2_q1 = np.kron(X_2_1, I)
X_CROT_q1 = np.dot(np.kron(X_2_1, Z_2_1), CNOT)
Z_CROT_q1 = np.dot(np.kron(I, Z_2_1), NCNOT)
CROT_q1 = np.dot(np.kron(I, Z_2_1), CNOT)

# Following generators operate on Q2.
X_2_q2 = swap(X_2_q1)
X_CROT_q2 = swap(X_CROT_q1)
Z_CROT_q2 = swap(Z_CROT_q1)
CROT_q2 = swap(CROT_q1)


def H_RWA1_1d(w):
    return 1/2*2*np.pi*w*np.array( [[0, 0, 0, 0],
                                    [0, 0, 0, 1],
                                    [0, 0, 0, 0],
                                    [0, 1, 0, 0]])

def H_RWA1_1u(w):
    return 1/2*2*np.pi*w*np.array( [[0, 0, 1, 0],
                                    [0, 0, 0, 0],
                                    [1, 0, 0, 0],
                                    [0, 0, 0, 0]])

def H_RWA2_1d(w, t):
    return 1/2*2*np.pi*w*np.array( [[                     0, 0, np.exp(-1j*J*2*np.pi*t), 0],
                                    [                     0, 0,                       0, 0],
                                    [np.exp(1j*J*2*np.pi*t), 0,                       0, 0],
                                    [                     0, 0,                       0, 0]] )

def H_RWA2_1u(w, t):
    return 1/2*2*np.pi*w*np.array( [[0,                       0, 0,                       0],
                                    [0,                       0, 0,  np.exp(1j*J*2*np.pi*t)],
                                    [0,                       0, 0,                       0],
                                    [0, np.exp(-1j*J*2*np.pi*t), 0,                       0]] )

def H_RWA_1d(w, t):
    return H_RWA1_1d(w) + H_RWA2_1d(w, t)

def H_RWA_1u(w, t):
    return H_RWA1_1u(w) + H_RWA2_1u(w, t)

def Fidelity(M_exp, M):
    return np.absolute(np.trace(np.dot(M_exp.conj().T, M)))/4

# some test for no-crosstalk-term Hamiltonians.
A = expm(-1j*H_RWA1_1d(Ω)*(1.0/(4.0*Ω)))   # U_1d_pi/2
B = expm(-1j*H_RWA1_1u(Ω)*(1.0/(4.0*Ω)))   # U_1u_pi/2
C = expm(1j*H_RWA1_1d(Ω)*(1.0/(4.0*Ω)))   # U_1d_-pi/2
D = expm(1j*H_RWA1_1u(Ω)*(1.0/(4.0*Ω)))   # U_1u_-pi/2

# Perfect gates generated by perfect pulses.
X_2_test_q1 = np.dot(B, A)
X_CROT_test_q1 = np.dot(B, C)
Z_CROT_test_q1 = np.dot(B, B)
CROT_test_q1 = np.dot(C, C)

delta = 100

U_1d_plus = np.identity(4)   # Unitary transformation from f_1d pulse. "Plus" indicates that it is a pi/2 rotation.
U_1u_plus = np.identity(4)
U_1d_minus = np.identity(4)
U_1u_minus = np.identity(4)
x = []
y_X_2 = []
y_X_CROT = []
y_Z_CROT = []
y_CROT = []


for i in range(200):
    T_pi_2 = (5 + i*10**(-2))*10**(-7)
    x.append(5 + i*10**(-2))
    print(T_pi_2)
    L = np.linspace(0, T_pi_2, delta)
    for t in L:
        U_1d_plus = np.dot(expm(-1j * H_RWA_1d(Ω, t) * L[1]), U_1d_plus)
        U_1u_plus = np.dot(expm(-1j * H_RWA_1u(Ω, t) * L[1]), U_1u_plus)
        U_1d_minus = np.dot(expm(1j * H_RWA_1d(Ω, t) * L[1]), U_1d_minus)
        U_1u_minus = np.dot(expm(1j * H_RWA_1u(Ω, t) * L[1]), U_1u_minus)
    X_2_noise_q1 = np.dot(U_1u_plus, U_1d_plus)
    X_CROT_noise_q1 = np.dot(U_1u_plus, U_1d_minus)
    Z_CROT_noise_q1 = np.dot(U_1u_plus, U_1u_plus)
    CROT_noise_q1 = np.dot(U_1d_minus, U_1d_minus)
    y_X_2.append(Fidelity(X_2_noise_q1, X_2_test_q1)*100)
    y_X_CROT.append(Fidelity(X_CROT_noise_q1, X_CROT_test_q1) * 100)
    y_Z_CROT.append(Fidelity(Z_CROT_noise_q1, Z_CROT_test_q1) * 100)
    y_CROT.append(Fidelity(CROT_noise_q1, CROT_test_q1) * 100)
    U_1d_plus = np.identity(4)
    U_1u_plus = np.identity(4)
    U_1d_minus = np.identity(4)
    U_1u_minus = np.identity(4)

def find_maximum_T(y, x):
    return x[y.index(np.amax(y))]


x[:] = [a * 100 for a in x]
plt.plot(x, y_X_2, 'b-', label="X_2")
plt.plot(x, y_X_CROT, 'r-', label="X_CROT")
plt.plot(x, y_Z_CROT, 'g-', label="Z_CROT")
plt.plot(x, y_CROT, 'y-', label="CROT")
plt.axvline(x=608.9, c='k')
plt.yticks(np.arange(98.8, 99.8, 0.05))
plt.xlabel("T_pi/2 (GHz-1)")
plt.ylabel("Fidelity (%)")
plt.xlim(left=500, right=700)
plt.ylim(bottom=98.8)
plt.legend(loc=4)
plt.show()

print("Best T for X_2 gate :", find_maximum_T(y_X_2, x), "GHz^-1 ; F(X_2) =", np.amax(y_X_2))
print("Best T for X_CROT gate : ", find_maximum_T(y_X_CROT, x), "GHz^-1 ; F(X_CROT) =", np.amax(y_X_CROT))
print("Best T for Z_CROT gate : ", find_maximum_T(y_Z_CROT, x), "GHz^-1 ; F(Z_CROT) =", np.amax(y_Z_CROT))
print("Best T for CROT gate : ", find_maximum_T(y_CROT, x), "GHz^-1 ; F(CROT) =", np.amax(y_CROT))



