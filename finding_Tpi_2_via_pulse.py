import numpy as np
from scipy.linalg import expm
import matplotlib.pyplot as plt
import math

def swap(M):
    SWAP = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])
    return np.dot(np.dot(SWAP, M), SWAP)


Ez = 3.933e10
dEz = 1.326e7
Ω = 410000.0
J = 1.59e6

n = 1
# T_pi_2 = 6.089596456300971e-07
# T_pi_2 = math.sqrt(16*n**2-1)/4/J
# T_pi_2 = 1.0/(4.0*Ω)

I = np.identity(2)
X = np.array([[0,   1], [1,  0]])
Y = np.array([[0, -1j], [1j, 0]])
Z = np.array([[1,   0], [0, -1]])

Z_2_1 = (1/np.sqrt(2))*np.array([[1-1j, 0+0j], [0+0j, 1+1j]])
CNOT = np.array([[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0]])
NCNOT = np.array([[0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1]])
X_2_1 = (1/np.sqrt(2))*np.array([[1+0j, 0-1j], [0-1j, 1+0j]])

# Following generators operate on Q1.
X_2_q1 = np.kron(X_2_1, I)
X_CROT_q1 = np.dot(np.kron(X_2_1, Z_2_1), CNOT)
Z_CROT_q1 = np.dot(np.kron(I, Z_2_1), NCNOT)
CROT_q1 = np.dot(np.kron(I, Z_2_1), CNOT)

# Following generators operate on Q2.
X_2_q2 = swap(X_2_q1)
X_CROT_q2 = swap(X_CROT_q1)
Z_CROT_q2 = swap(Z_CROT_q1)
CROT_q2 = swap(CROT_q1)



def H_RWA1_1d(w):
    return 1/2*2*np.pi*w*np.array( [[0, 0, 0, 0],
                                    [0, 0, 0, 1],
                                    [0, 0, 0, 0],
                                    [0, 1, 0, 0]])

def H_RWA1_1u(w):
    return 1/2*2*np.pi*w*np.array( [[0, 0, 1, 0],
                                    [0, 0, 0, 0],
                                    [1, 0, 0, 0],
                                    [0, 0, 0, 0]])

def H_RWA2_1d(w, t):
    return 1/2*2*np.pi*w*np.array( [[                     0, 0, np.exp(-1j*J*2*np.pi*t), 0],
                                    [                     0, 0,                       0, 0],
                                    [np.exp(1j*J*2*np.pi*t), 0,                       0, 0],
                                    [                     0, 0,                       0, 0]] )

def H_RWA2_1u(w, t):
    return 1/2*2*np.pi*w*np.array( [[0,                       0, 0,                       0],
                                    [0,                       0, 0,  np.exp(1j*J*2*np.pi*t)],
                                    [0,                       0, 0,                       0],
                                    [0, np.exp(-1j*J*2*np.pi*t), 0,                       0]] )

def H_RWA_1d(w, t):
    return H_RWA1_1d(w) + H_RWA2_1d(w, t)

def H_RWA_1u(w, t):
    return H_RWA1_1u(w) + H_RWA2_1u(w, t)

def Fidelity(M_exp, M):
    return np.absolute(np.trace(np.dot(M_exp.conj().T, M)))/4

# some test for no-crosstalk-term Hamiltonians.
A = expm(-1j*H_RWA1_1d(Ω)*(1.0/(4.0*Ω)))   # U_1d_pi/2
# B = expm(-1j*H_RWA1_1u(Ω)*(1.0/(4.0*Ω)))   # U_1u_pi/2
# C = expm(1j*H_RWA1_1d(Ω)*(1.0/(4.0*Ω)))   # U_1d_-pi/2
# D = expm(1j*H_RWA1_1u(Ω)*(1.0/(4.0*Ω)))   # U_1u_-pi/2

# Perfect gates generated by perfect pulses.
# X_2_test_q1 = np.dot(B, A)
# X_CROT_test_q1 = np.dot(B, C)
# Z_CROT_test_q1 = np.dot(B, B)
# CROT_test_q1 = np.dot(C, C)

# print("F(1): ", Fidelity(X_2_q1, X_2_test_q1))
# print("F(2): ", Fidelity(X_CROT_q1, X_CROT_test_q1))
# print("F(3): ", Fidelity(Z_CROT_q1, Z_CROT_test_q1))
# print("F(4): ", Fidelity(CROT_q1, CROT_test_q1))

delta = 100

# L = np.linspace(0, T_pi_2, delta)

U_1d_plus = np.identity(4)   # Unitary transformation from f_1d pulse. "Plus" indicates that it is a pi/2 rotation.
U_1u_plus = np.identity(4)
U_1d_minus = np.identity(4)
U_1u_minus = np.identity(4)
x = []
y = []

#######################################################################################

# for t in L:
#     U_1d_plus = np.dot(expm(-1j * H_RWA_1d(Ω, t) * L[1]), U_1d_plus)
#     # U_1u_plus = np.dot(expm(-1j * H_RWA_1u(Ω, t) * L[1]), U_1u_plus)
#     # U_1d_minus = np.dot(expm(1j * H_RWA_1d(Ω, t) * L[1]), U_1d_minus)
#     # U_1u_minus = np.dot(expm(1j * H_RWA_1u(Ω, t) * L[1]), U_1u_minus)
# print("F(U_1d_plus): ", Fidelity(U_1d_plus, A))

#######################################################################################

for i in range(200):
    T_pi_2 = (5 + i*10**(-2))*10**(-7)
    x.append(5 + i*10**(-2))
    print(T_pi_2)
    L = np.linspace(0, T_pi_2, delta)
    for t in L:
        U_1d_plus = np.dot(expm(-1j * H_RWA_1d(Ω, t) * L[1]), U_1d_plus)
    y.append(Fidelity(U_1d_plus, A)*100)
    print("F(U_1d_plus): ", Fidelity(U_1d_plus, A))
    U_1d_plus = np.identity(4)

x[:] = [a * 100 for a in x]
plt.plot(x, y, 'b-')
plt.axvline(x=608.9, c='k')
plt.yticks(np.arange(98.8, 99.8, 0.05))
plt.xlabel("T_pi/2 (GHz-1)")
plt.ylabel("U_1d_pi/2 Fidelity (%)")
plt.xlim(left=500, right=700)
plt.ylim(bottom=98.8)
plt.show()

#######################################################################################

# X_2_exp_q1 = np.dot(U_1u_plus, U_1d_plus)
# X_CROT_exp_q1 = np.dot(U_1u_plus, U_1d_minus)
# Z_CROT_exp_q1 = np.dot(U_1u_plus, U_1u_plus)
# CROT_exp_q1 = np.dot(U_1d_minus, U_1d_minus)

# print("F(X_2_q1): ", Fidelity(X_2_exp_q1, X_2_q1))
# print("F(X_CROT_q1): ", Fidelity(X_CROT_exp_q1, X_CROT_q1))
# print("F(Z_CROT_q1): ", Fidelity(Z_CROT_exp_q1, Z_CROT_q1))
# print("F(CROT_q1): ", Fidelity(CROT_exp_q1, CROT_q1))
# print("\n")
# print("F(U_1d_plus): ", Fidelity(U_1d_plus, A))
# print("F(U_1u_plus): ", Fidelity(U_1u_plus, B))
# print("F(U_1d_minus): ", Fidelity(U_1d_minus, C))
# print("F(U_1u_minus): ", Fidelity(U_1u_minus, D))

